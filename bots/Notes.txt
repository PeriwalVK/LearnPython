I want to make a state machine kind of thing 
where is bot fails somewhere? I may manually intervene and then provide him input for next step.
various ways to do intervene

Method 1-

def current_step(self):
    try:
        # execute current function steps

        self.<whatever next method you want to call>()
    except Exception as e:
        next = input("After manual intervention, at which step you want driver to continue from?")
        # now decide based on input (after checking validity of input if it is correct string)
        self.<whatever next step>()

################################################################################################################
################################################################################################################


Method 2 - defining a workflow

    def __init__(self, driver):
        self.driver = driver

        # --- Workflow mapping: step_name -> bound method ---
        self.workflow = {
            "origin_destination": self.step_search_button,
            "search_button": self.step_select_train,
            "select_train": None  # last step
        }
    def run_workflow(self):
        current_step = "origin_destination"
        while current_step:
            try:
                workflow_func = self.workflow[current_step]
                if workflow_func is None:
                    print("✅ Workflow complete!")
                    break

                workflow_func()  # call bound method
                # Move to next step automatically
                next_steps = {v: k for k, v in self.workflow.items() if v == workflow_func}
                current_step = next_steps.get(workflow_func, None)

            except Exception as e:
                print(f"Step '{current_step}' failed: {e}")
                # Ask user which step to execute manually
                manual_step = input("Enter the next step to execute manually (or same to retry): ").strip()
                if manual_step in self.workflow:
                    current_step = manual_step
                    input("Perform manual actions in browser, then press Enter to continue...")
                else:
                    print("Invalid step. Retrying current step.")

################################################################################################################
################################################################################################################

Method 3 - using decorators
first learn from 
https://builtin.com/software-engineering-perspectives/python-class-decorator

then something like 




from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from functools import wraps

class IRCTCAutomation:
    def __init__(self, driver):
        self.driver = driver
        self.workflow = {}  # step_name -> bound method

    # --- Decorator for step registration ---
    def step(self, name):
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                try:
                    print(f"➡ Executing step: {name}")
                    result = func(*args, **kwargs)
                    print(f"✅ Step '{name}' completed successfully")
                    return result
                except Exception as e:
                    print(f"⚠ Step '{name}' failed: {e}")
                    input("Perform manual actions in browser, then press Enter to continue...")
                    return func(*args, **kwargs)  # retry after manual intervention

            # Register step in workflow
            self.workflow[name] = wrapper
            return wrapper
        return decorator

    # --- Step definitions ---
    @step("origin_destination")
    def fill_origin_destination(self):
        self.driver.find_element(By.ID, "origin").send_keys("Mumbai")
        self.driver.find_element(By.ID, "destination").send_keys("Delhi")

    @step("search_button")
    def click_search_button(self):
        xpath = "/html/body/app-root/app-home/div[3]/div/app-main-page/div/div/div[1]/div[1]/div[1]/app-jp-input/div/form/div[5]/div[1]/button"
        WebDriverWait(self.driver, 20).until(
            EC.element_to_be_clickable((By.XPATH, xpath))
        ).click()

    @step("select_train")
    def select_train(self):
        xpath = "//div[@class='train_availability_table']//button"
        WebDriverWait(self.driver, 20).until(
            EC.element_to_be_clickable((By.XPATH, xpath))
        ).click()

    # --- Runner ---
    def run_workflow(self):
        current_step = "origin_destination"
        while current_step:
            workflow_func = self.workflow.get(current_step)
            if workflow_func is None:
                print("✅ Workflow complete!")
                break
            workflow_func()  # automatically handles exceptions/manual pause

            # Move to next step based on workflow order
            step_names = list(self.workflow.keys())
            idx = step_names.index(current_step)
            current_step = step_names[idx + 1] if idx + 1 < len(step_names) else None


################################################################################################################
################################################################################################################

